import * as Notifications from 'expo-notifications';
import { Platform } from 'react-native';

Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: false,
    shouldSetBadge: false,
  }),
});

// Simple notification service for web compatibility
class SimpleNotificationService {
  private pushToken: string | null = null;
  private pushEnabled = false;
  private initialized = false;

  constructor() {
    // Initialize safely without async operations
    this.pushToken = null;
    this.pushEnabled = false;
  }

  private async initializePushNotifications() {
    if (Platform.OS === 'web') {
      try {
        // Try to get push token for web
        this.pushToken = await HybridDatabase.getPushToken();
        if (this.pushToken) {
          this.pushEnabled = true;
          console.log('‚úÖ Push notifications enabled for web');

          // Setup listener for incoming push messages
          HybridDatabase.setupPushNotificationListener((payload) => {
            this.handleIncomingPushNotification(payload);
          });
        } else {
          console.log('‚ÑπÔ∏è Push notifications not configured for web');
        }
      } catch (error) {
        console.warn('‚ùå Push notifications not available for web:', error);
        this.pushEnabled = false;
        this.pushToken = null;
      }
    }
  }

  // Fallback method if HybridDatabase is not available
  private async tryInitializeWithFallback() {
    if (Platform.OS === 'web') {
      try {
        // Import firebase messaging directly
        const { getMessaging, getToken } = await import('firebase/messaging');
        const { initializeApp } = await import('firebase/app');
        const { firebaseConfig } = await import('../firebase.config');

        const app = initializeApp(firebaseConfig);
        const messaging = getMessaging(app);

        const token = await getToken(messaging, {
          vapidKey: process.env.EXPO_PUBLIC_FIREBASE_VAPID_KEY || 'your-vapid-key'
        });

        if (token) {
          this.pushToken = token;
          this.pushEnabled = true;
          console.log('‚úÖ Push notifications enabled with fallback');
        }
      } catch (error) {
        console.warn('‚ùå Fallback push initialization failed:', error);
      }
    }
  }

  private handleIncomingPushNotification(payload: any) {
    console.log('üì≤ Push notification received:', payload);

    // Handle push notification - you can customize this
    if (payload?.notification) {
      // Show local notification for push message
      Notifications.presentNotificationAsync({
        title: payload.notification.title,
        body: payload.notification.body,
        data: payload.data,
      });
    }
  }

  public async getPushToken(): Promise<string | null> {
    // If already have a token, return it
    if (this.pushToken) {
      return this.pushToken;
    }

    // Try to get token with fallback
    try {
      if (Platform.OS === 'web') {
        await this.tryInitializeWithFallback();
      }
    } catch (error) {
      console.warn('Failed to get push token:', error);
    }

    return this.pushToken;
  }

  public isPushEnabled(): boolean {
    return this.pushEnabled && this.initialized;
  }

  public isInitialized(): boolean {
    return this.initialized;
  }
}

// Singleton instance
export const enhancedNotifications = new EnhancedNotificationService();

export const schedulePedidoNotification = async (pedidoId: number, title: string, body: string, triggerDate: Date): Promise<string | null> => {
  if (Platform.OS === 'web') return null;
  if (triggerDate.getTime() <= Date.now()) return null;
  const id = await Notifications.scheduleNotificationAsync({
    content: { title, body },
    trigger: triggerDate,
  });
  return id;
};

export const cancelNotificationById = async (notificationId: string | null | undefined): Promise<void> => {
  if (!notificationId || Platform.OS === 'web') return;
  try {
    await Notifications.cancelScheduledNotificationAsync(notificationId);
  } catch {
    // noop
  }
};


